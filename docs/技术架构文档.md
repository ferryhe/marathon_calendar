# 马拉松日历应用技术架构文档

## 1. 系统架构概览

### 1.1 整体架构图

```
┌──────────────────────────────────────────────────────────────┐
│                          用户层                               │
├──────────────┬────────────────┬────────────────┬─────────────┤
│   Web浏览器   │   微信小程序    │   移动浏览器    │   管理后台   │
└──────┬───────┴────────┬───────┴────────┬──────┴─────┬───────┘
       │                │                │             │
       │                │    HTTPS       │             │
       └────────────────┴────────────────┴─────────────┘
                              │
                    ┌─────────▼──────────┐
                    │   腾讯云 CDN        │
                    └─────────┬──────────┘
                              │
                    ┌─────────▼──────────┐
                    │   负载均衡（可选）   │
                    └─────────┬──────────┘
                              │
       ┌──────────────────────┴──────────────────────┐
       │                                              │
┌──────▼───────┐                            ┌────────▼────────┐
│  Express API │                            │   静态资源服务   │
│   Node.js    │                            │   (Vite Build)  │
└──────┬───────┘                            └─────────────────┘
       │
       ├─────────────┬──────────────┬──────────────┐
       │             │              │              │
┌──────▼──────┐ ┌───▼────┐  ┌─────▼─────┐  ┌────▼─────┐
│ PostgreSQL  │ │ Redis  │  │  爬虫系统  │  │ AI服务   │
│   数据库     │ │  缓存   │  │ (Puppeteer)│ │ (通义千问)│
└─────────────┘ └────────┘  └───────────┘  └──────────┘
```

### 1.2 技术栈总览

| 层级 | 技术选型 | 说明 |
|-----|---------|------|
| 前端框架 | React 19 + TypeScript | 现代化前端框架 |
| 构建工具 | Vite | 快速开发和构建 |
| UI库 | Radix UI + Tailwind CSS | 组件库 + 样式框架 |
| 状态管理 | TanStack Query | 服务端状态管理 |
| 后端框架 | Express 5 + TypeScript | Node.js Web框架 |
| ORM | Drizzle ORM | 类型安全的数据库工具 |
| 数据库 | PostgreSQL 14+ | 关系型数据库 |
| 缓存 | Redis | 内存数据库 |
| 爬虫 | Puppeteer + Cheerio | 网页数据采集 |
| AI服务 | 通义千问 API | 智能数据提取 |
| 云平台 | 腾讯云 | 云服务提供商 |

---

## 2. 数据库设计

### 2.1 核心表结构

#### users - 用户表
```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username TEXT UNIQUE,                    -- Web端用户名（可选）
  password TEXT,                           -- 密码哈希（可选）
  wechat_openid TEXT UNIQUE,              -- 微信OpenID（小程序）
  wechat_unionid TEXT,                    -- 微信UnionID（可选）
  nickname TEXT,                          -- 昵称
  avatar_url TEXT,                        -- 头像URL
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_users_wechat_openid ON users(wechat_openid);
```

#### marathons - 马拉松基础信息表
```sql
CREATE TABLE marathons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,                     -- 完整名称
  canonical_name TEXT NOT NULL UNIQUE,    -- 标准化名称（如"北京马拉松"）
  city TEXT,                              -- 城市
  country TEXT DEFAULT '中国',            -- 国家
  province TEXT,                          -- 省份
  description TEXT,                       -- 描述
  website_url TEXT,                       -- 官网
  logo_url TEXT,                          -- Logo图片
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_marathons_canonical ON marathons(canonical_name);
CREATE INDEX idx_marathons_city ON marathons(city);
```

#### marathon_editions - 年度赛事信息表
```sql
CREATE TABLE marathon_editions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  marathon_id UUID NOT NULL REFERENCES marathons(id) ON DELETE CASCADE,
  year INTEGER NOT NULL,                             -- 年份
  race_date DATE,                                    -- 比赛日期
  registration_status TEXT,                          -- 报名状态
  registration_url TEXT,                             -- 报名链接
  registration_open_date DATE,                       -- 报名开始日期
  registration_close_date DATE,                      -- 报名截止日期
  registration_fee TEXT,                             -- 报名费用
  max_participants INTEGER,                          -- 最大参赛人数
  distance_types TEXT[],                            -- 比赛项目（全马、半马等）
  last_synced_at TIMESTAMP WITH TIME ZONE,          -- 最后同步时间
  next_sync_at TIMESTAMP WITH TIME ZONE,            -- 下次同步时间
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(marathon_id, year)
);

CREATE INDEX idx_editions_race_date ON marathon_editions(race_date);
CREATE INDEX idx_editions_status ON marathon_editions(registration_status);
CREATE INDEX idx_editions_marathon ON marathon_editions(marathon_id);
```

#### sources - 数据源表
```sql
CREATE TABLE sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,              -- 数据源名称
  type TEXT NOT NULL,                     -- 类型：official/platform/search
  base_url TEXT,                          -- 基础URL
  priority INTEGER DEFAULT 0,             -- 优先级（数字越大优先级越高）
  is_active BOOLEAN DEFAULT true,         -- 是否启用
  notes TEXT,                             -- 备注
  config JSONB,                           -- 配置信息
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_sources_type ON sources(type);
CREATE INDEX idx_sources_active ON sources(is_active);
```

#### marathon_sources - 马拉松数据源关系表
```sql
CREATE TABLE marathon_sources (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  marathon_id UUID NOT NULL REFERENCES marathons(id) ON DELETE CASCADE,
  source_id UUID NOT NULL REFERENCES sources(id) ON DELETE CASCADE,
  source_url TEXT NOT NULL,               -- 具体URL
  is_primary BOOLEAN DEFAULT false,       -- 是否为主数据源
  last_checked_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(marathon_id, source_id)
);

CREATE INDEX idx_ms_marathon ON marathon_sources(marathon_id);
CREATE INDEX idx_ms_source ON marathon_sources(source_id);
```

#### marathon_sync_runs - 同步记录表
```sql
CREATE TABLE marathon_sync_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  marathon_id UUID REFERENCES marathons(id) ON DELETE CASCADE,
  source_id UUID REFERENCES sources(id) ON DELETE SET NULL,
  status TEXT NOT NULL,                   -- running/success/failed/retrying
  total_events INTEGER DEFAULT 0,
  new_count INTEGER DEFAULT 0,
  updated_count INTEGER DEFAULT 0,
  unchanged_count INTEGER DEFAULT 0,
  error_message TEXT,
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  finished_at TIMESTAMP WITH TIME ZONE,
  duration_seconds INTEGER
);

CREATE INDEX idx_sync_marathon ON marathon_sync_runs(marathon_id);
CREATE INDEX idx_sync_status ON marathon_sync_runs(status);
CREATE INDEX idx_sync_started ON marathon_sync_runs(started_at);
```

#### raw_crawl_data - 原始爬取数据表
```sql
CREATE TABLE raw_crawl_data (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  source_id UUID REFERENCES sources(id) ON DELETE CASCADE,
  source_url TEXT NOT NULL,
  content_type TEXT,                      -- html/json/xml
  raw_content TEXT,                       -- 原始内容
  content_hash TEXT,                      -- 内容哈希（用于变更检测）
  metadata JSONB,                         -- 元数据
  status TEXT DEFAULT 'pending',          -- pending/processed/failed
  processed_at TIMESTAMP WITH TIME ZONE,
  fetched_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_raw_source ON raw_crawl_data(source_id);
CREATE INDEX idx_raw_hash ON raw_crawl_data(content_hash);
CREATE INDEX idx_raw_status ON raw_crawl_data(status);
```

#### marathon_reviews - 评论表
```sql
CREATE TABLE marathon_reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  marathon_id UUID NOT NULL REFERENCES marathons(id) ON DELETE CASCADE,
  marathon_edition_id UUID REFERENCES marathon_editions(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  user_display_name TEXT NOT NULL,        -- 显示名称
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT,
  images TEXT[],                          -- 评论图片URL数组
  likes_count INTEGER DEFAULT 0,          -- 点赞数
  is_deleted BOOLEAN DEFAULT false,       -- 软删除标记
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_reviews_marathon ON marathon_reviews(marathon_id);
CREATE INDEX idx_reviews_edition ON marathon_reviews(marathon_edition_id);
CREATE INDEX idx_reviews_user ON marathon_reviews(user_id);
CREATE INDEX idx_reviews_created ON marathon_reviews(created_at DESC);
```

#### user_favorites - 用户收藏表
```sql
CREATE TABLE user_favorites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  marathon_id UUID NOT NULL REFERENCES marathons(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, marathon_id)
);

CREATE INDEX idx_favorites_user ON user_favorites(user_id);
```

#### wechat_subscriptions - 微信订阅表
```sql
CREATE TABLE wechat_subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  marathon_edition_id UUID NOT NULL REFERENCES marathon_editions(id) ON DELETE CASCADE,
  subscription_type TEXT NOT NULL,        -- registration_open/race_reminder
  is_sent BOOLEAN DEFAULT false,          -- 是否已发送
  sent_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, marathon_edition_id, subscription_type)
);

CREATE INDEX idx_subs_unsent ON wechat_subscriptions(is_sent) WHERE is_sent = false;
```

### 2.2 数据库索引策略

**查询热点分析：**
1. 按日期查询赛事（高频）
2. 按城市查询赛事（高频）
3. 按状态查询赛事（高频）
4. 查询用户评论（中频）
5. 查询同步记录（低频）

**索引优化：**
- 复合索引：(city, race_date) 用于地区时间组合查询
- 部分索引：仅索引未来的赛事，减少索引大小
- 覆盖索引：包含常用查询字段，避免回表

---

## 3. API设计

### 3.1 RESTful API规范

#### 基础URL
```
开发环境：http://localhost:3000/api
生产环境：https://api.marathon-calendar.com/api
```

#### 响应格式

**成功响应：**
```json
{
  "success": true,
  "data": {},
  "message": "操作成功"
}
```

**错误响应：**
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "参数验证失败",
    "details": [
      {
        "field": "email",
        "message": "邮箱格式不正确"
      }
    ]
  }
}
```

**分页响应：**
```json
{
  "success": true,
  "data": {
    "items": [],
    "pagination": {
      "total": 100,
      "page": 1,
      "pageSize": 20,
      "totalPages": 5
    }
  }
}
```

### 3.2 核心API接口

#### 赛事相关

```
GET    /api/marathons
       查询参数：
       - year: 年份
       - month: 月份  
       - city: 城市
       - province: 省份
       - status: 报名状态
       - page: 页码（默认1）
       - pageSize: 每页数量（默认20，最大100）
       - sortBy: 排序字段（date/name）
       - sortOrder: 排序方向（asc/desc）

GET    /api/marathons/:id
       获取赛事详情

GET    /api/marathons/:id/editions
       获取赛事历年信息

GET    /api/marathons/search
       查询参数：
       - q: 搜索关键词
       - page, pageSize

GET    /api/marathons/upcoming
       获取即将举办的赛事
       查询参数：
       - days: 未来N天内（默认30）
       - limit: 返回数量（默认10）

GET    /api/marathons/hot
       获取热门赛事（按评论数、收藏数）
```

#### 评论相关

```
GET    /api/reviews
       查询参数：
       - marathonId: 赛事ID（必填）
       - editionId: 年度赛事ID（可选）
       - page, pageSize
       - sortBy: created_at/rating/likes

POST   /api/reviews
       请求体：
       {
         "marathonId": "uuid",
         "editionId": "uuid", // 可选
         "rating": 5,
         "comment": "很棒的赛事！"
       }

PUT    /api/reviews/:id
       更新评论（仅限本人）

DELETE /api/reviews/:id
       删除评论（仅限本人）

POST   /api/reviews/:id/like
       点赞评论
```

#### 用户相关

```
POST   /api/auth/register
       请求体：
       {
         "username": "user123",
         "password": "password123"
       }

POST   /api/auth/login
       请求体：
       {
         "username": "user123",
         "password": "password123"
       }

POST   /api/auth/logout

POST   /api/auth/wechat/login
       微信登录
       请求体：
       {
         "code": "wx_code"
       }

GET    /api/users/me
       获取当前用户信息

PUT    /api/users/me
       更新用户信息

GET    /api/users/me/reviews
       获取我的评论

GET    /api/users/me/favorites
       获取我的收藏

POST   /api/users/me/favorites
       添加收藏
       请求体：
       {
         "marathonId": "uuid"
       }

DELETE /api/users/me/favorites/:marathonId
       取消收藏
```

#### 管理后台API

```
GET    /api/admin/stats
       系统统计信息

GET    /api/admin/sync-runs
       同步记录列表

POST   /api/admin/sync-runs
       手动触发同步
       请求体：
       {
         "marathonId": "uuid", // 可选，不传则同步所有
         "sourceId": "uuid"    // 可选
       }

GET    /api/admin/sources
       数据源管理

POST   /api/admin/sources
       添加数据源

PUT    /api/admin/sources/:id
       更新数据源配置
```

### 3.3 认证与授权

#### 认证方式

**Web端：Session Based**
```javascript
// 使用express-session + connect-pg-simple
// 已在现有代码中实现
```

**小程序端：JWT Token**
```javascript
// 流程：
// 1. 小程序调用wx.login()获取code
// 2. 将code发送到后端 POST /api/auth/wechat/login
// 3. 后端用code换取openid
// 4. 返回JWT token
// 5. 小程序在后续请求中携带token

// JWT Payload示例
{
  "userId": "uuid",
  "openid": "wechat_openid",
  "type": "wechat",
  "iat": 1234567890,
  "exp": 1234567890
}
```

#### 权限控制

```javascript
// 中间件示例
export function requireAuth(req, res, next) {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      error: { message: '未登录' }
    });
  }
  next();
}

export function requireAdmin(req, res, next) {
  if (!req.user?.isAdmin) {
    return res.status(403).json({
      success: false,
      error: { message: '权限不足' }
    });
  }
  next();
}
```

---

## 4. 爬虫系统架构

### 4.1 爬虫工作流程

```
┌──────────────┐
│ 调度器启动    │
└──────┬───────┘
       │
       ▼
┌──────────────┐
│ 获取待采集列表│ ← marathon_sources表
└──────┬───────┘
       │
       ▼
┌──────────────────┐
│ 创建采集任务队列  │
└──────┬───────────┘
       │
       ├─────────────┬─────────────┐
       ▼             ▼             ▼
  ┌────────┐    ┌────────┐    ┌────────┐
  │ Worker1│    │ Worker2│    │ Worker3│ (并发处理)
  └────┬───┘    └────┬───┘    └────┬───┘
       │             │             │
       └─────────────┴─────────────┘
                     │
                     ▼
            ┌────────────────┐
            │  获取网页内容   │ (Puppeteer/Axios)
            └────────┬───────┘
                     │
                     ▼
            ┌────────────────┐
            │ 保存原始数据    │ → raw_crawl_data表
            └────────┬───────┘
                     │
            ┌────────▼────────┐
            │  尝试传统解析   │ (Cheerio + 规则)
            └────────┬────────┘
                     │
            ┌────────▼────────┐
            │  成功？          │
            └────────┬────────┘
                ┌────┴────┐
              成功       失败
                │         │
                │    ┌────▼─────┐
                │    │ AI提取   │ (通义千问)
                │    └────┬─────┘
                │         │
                └────┬────┘
                     │
                     ▼
            ┌────────────────┐
            │  数据验证清洗   │
            └────────┬───────┘
                     │
                     ▼
            ┌────────────────┐
            │  对比现有数据   │
            └────────┬───────┘
                     │
            ┌────────▼────────┐
            │  有变更？        │
            └────────┬────────┘
                ┌────┴────┐
               有         无
                │         │
        ┌───────▼──┐   ┌──▼─────┐
        │ 更新数据  │   │ 记录日志│
        └───────┬──┘   └────────┘
                │
                ▼
        ┌───────────────┐
        │ 记录同步结果   │ → marathon_sync_runs表
        └───────────────┘
```

### 4.2 数据源抽象

```typescript
// crawler/sources/BaseSource.ts
export abstract class BaseSource {
  abstract sourceId: string;
  abstract name: string;
  abstract baseUrl: string;
  abstract strategy: 'HTML' | 'API' | 'RSS';
  abstract priority: number;

  // 获取原始数据
  abstract fetchRawData(url: string): Promise<string>;

  // 解析为结构化数据
  abstract parseData(rawData: string): ParsedEvent[];

  // 验证数据
  validateData(event: ParsedEvent): boolean {
    // 通用验证逻辑
    return !!(event.name && event.city && event.date);
  }

  // 执行完整流程
  async execute(): Promise<void> {
    try {
      const raw = await this.fetchRawData(this.baseUrl);
      await this.saveRawData(raw);
      
      let events: ParsedEvent[];
      try {
        events = this.parseData(raw);
      } catch (error) {
        // 传统解析失败，使用AI
        events = await this.aiExtract(raw);
      }

      await this.processEvents(events);
    } catch (error) {
      await this.logError(error);
    }
  }
}

// 具体实现示例
export class BeijingMarathonSource extends BaseSource {
  sourceId = 'beijing-marathon-official';
  name = '北京马拉松官网';
  baseUrl = 'https://www.beijing-marathon.com';
  strategy = 'HTML';
  priority = 10;

  async fetchRawData(url: string): Promise<string> {
    // 使用Puppeteer获取页面
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(url);
    const html = await page.content();
    await browser.close();
    return html;
  }

  parseData(rawData: string): ParsedEvent[] {
    // 使用Cheerio解析
    const $ = cheerio.load(rawData);
    const events: ParsedEvent[] = [];
    
    $('.event-item').each((i, elem) => {
      events.push({
        name: $(elem).find('.title').text(),
        city: '北京',
        date: $(elem).find('.date').text(),
        // ...
      });
    });
    
    return events;
  }
}
```

### 4.3 AI辅助提取模块

```typescript
// crawler/ai/aiExtractor.ts
import Anthropic from '@anthropic-ai/sdk';

export class AIExtractor {
  private client: Anthropic;
  private costMonitor: CostMonitor;

  constructor() {
    this.client = new Anthropic({
      apiKey: process.env.AI_API_KEY,
    });
    this.costMonitor = new CostMonitor();
  }

  async extractEvents(htmlContent: string): Promise<ParsedEvent[]> {
    // 检查成本限制
    if (!this.costMonitor.canMakeRequest()) {
      throw new Error('AI调用已达每日上限');
    }

    const prompt = this.buildPrompt(htmlContent);
    
    try {
      const response = await this.client.messages.create({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 2000,
        messages: [{
          role: 'user',
          content: prompt
        }]
      });

      this.costMonitor.recordRequest(response);
      
      return this.parseAIResponse(response.content);
    } catch (error) {
      logger.error('AI提取失败', error);
      throw error;
    }
  }

  private buildPrompt(html: string): string {
    // 清理HTML
    const cleanedHtml = this.cleanHTML(html);
    
    return `
请从以下网页内容中提取马拉松赛事信息。

网页内容：
${cleanedHtml}

请以JSON数组格式返回，每个赛事包含以下字段：
{
  "name": "赛事全称",
  "canonicalName": "标准化名称",
  "city": "城市",
  "raceDate": "比赛日期(YYYY-MM-DD)",
  "registrationStatus": "open|closed|sold-out|unknown",
  "registrationUrl": "报名链接",
  "registrationOpenDate": "报名开始日期(YYYY-MM-DD)",
  "registrationCloseDate": "报名截止日期(YYYY-MM-DD)",
  "websiteUrl": "官网链接"
}

注意：
1. 如果字段无法确定，设为null
2. canonicalName格式为"城市+马拉松"
3. 日期必须是YYYY-MM-DD格式
    `.trim();
  }
}
```

### 4.4 任务调度

```typescript
// crawler/scheduler.ts
import cron from 'node-cron';

export class CrawlerScheduler {
  private sources: BaseSource[];
  
  constructor() {
    this.sources = this.loadSources();
  }

  start() {
    // 每天凌晨2点执行高优先级源
    cron.schedule('0 2 * * *', async () => {
      await this.runHighPrioritySources();
    });

    // 每周日凌晨3点执行全量同步
    cron.schedule('0 3 * * 0', async () => {
      await this.runAllSources();
    });

    // 每小时检查即将开始报名的赛事
    cron.schedule('0 * * * *', async () => {
      await this.checkUpcomingRegistrations();
    });
  }

  private async runHighPrioritySources() {
    const highPriority = this.sources
      .filter(s => s.priority >= 8)
      .sort((a, b) => b.priority - a.priority);

    for (const source of highPriority) {
      try {
        await source.execute();
      } catch (error) {
        logger.error(`数据源执行失败: ${source.name}`, error);
      }
    }
  }
}
```

---

## 5. 缓存策略

### 5.1 多级缓存架构

```
请求 → CDN缓存 → Nginx缓存 → Redis缓存 → 应用缓存 → 数据库
```

### 5.2 缓存配置

```typescript
// server/cache.ts
import Redis from 'ioredis';

export const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: Number(process.env.REDIS_PORT),
  password: process.env.REDIS_PASSWORD,
});

// 缓存键命名规范
export const CacheKeys = {
  marathonList: (params: any) => 
    `marathon:list:${JSON.stringify(params)}`,
  marathonDetail: (id: string) => 
    `marathon:detail:${id}`,
  marathonReviews: (id: string, page: number) => 
    `marathon:reviews:${id}:${page}`,
  upcomingMarathons: () => 
    `marathon:upcoming`,
};

// TTL配置（秒）
export const CacheTTL = {
  marathonList: 1800,      // 30分钟
  marathonDetail: 3600,    // 1小时
  marathonReviews: 600,    // 10分钟
  upcomingMarathons: 1800, // 30分钟
  userSession: 604800,     // 7天
};

// 缓存辅助函数
export async function cacheGet<T>(key: string): Promise<T | null> {
  const cached = await redis.get(key);
  return cached ? JSON.parse(cached) : null;
}

export async function cacheSet(
  key: string, 
  value: any, 
  ttl: number
): Promise<void> {
  await redis.setex(key, ttl, JSON.stringify(value));
}

export async function cacheInvalidate(pattern: string): Promise<void> {
  const keys = await redis.keys(pattern);
  if (keys.length > 0) {
    await redis.del(...keys);
  }
}
```

### 5.3 缓存更新策略

```typescript
// 数据更新时自动失效相关缓存
export async function invalidateMarathonCache(marathonId: string) {
  await Promise.all([
    cacheInvalidate(`marathon:detail:${marathonId}`),
    cacheInvalidate(`marathon:reviews:${marathonId}:*`),
    cacheInvalidate(`marathon:list:*`),
    cacheInvalidate(`marathon:upcoming`),
  ]);
}
```

---

## 6. 性能优化

### 6.1 前端优化

```typescript
// 1. 代码分割
const MarathonDetail = lazy(() => import('./pages/MarathonDetail'));
const UserProfile = lazy(() => import('./pages/UserProfile'));

// 2. 虚拟滚动（大列表）
import { useVirtualizer } from '@tanstack/react-virtual';

// 3. 图片懒加载
<img loading="lazy" src={imageUrl} alt="..." />

// 4. 预加载关键数据
queryClient.prefetchQuery({
  queryKey: ['marathons', 'upcoming'],
  queryFn: fetchUpcomingMarathons,
});
```

### 6.2 后端优化

```typescript
// 1. 数据库查询优化
// 使用索引、限制返回字段
const marathons = await db
  .select({
    id: marathons.id,
    name: marathons.name,
    city: marathons.city,
  })
  .from(marathons)
  .where(conditions)
  .limit(pageSize)
  .offset((page - 1) * pageSize);

// 2. N+1查询问题解决
// 使用JOIN或批量查询
const marathonsWithEditions = await db
  .select()
  .from(marathons)
  .leftJoin(marathonEditions, 
    eq(marathons.id, marathonEditions.marathonId))
  .where(conditions);

// 3. 连接池配置
import { Pool } from 'pg';
const pool = new Pool({
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

### 6.3 CDN配置

```nginx
# 静态资源缓存
location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff2)$ {
  expires 1y;
  add_header Cache-Control "public, immutable";
}

# HTML文件不缓存
location ~* \.(html)$ {
  expires -1;
  add_header Cache-Control "no-cache, no-store, must-revalidate";
}
```

---

## 7. 安全措施

### 7.1 身份认证安全

```typescript
// 1. 密码哈希
import bcrypt from 'bcrypt';

async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

async function verifyPassword(
  password: string, 
  hash: string
): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// 2. JWT签名
import jwt from 'jsonwebtoken';

function generateToken(payload: any): string {
  return jwt.sign(payload, process.env.JWT_SECRET!, {
    expiresIn: '7d',
  });
}

// 3. CSRF保护（Web端）
// 使用csurf中间件
import csrf from 'csurf';
app.use(csrf({ cookie: true }));
```

### 7.2 输入验证

```typescript
// 使用Zod进行数据验证
import { z } from 'zod';

export const reviewSchema = z.object({
  marathonId: z.string().uuid(),
  rating: z.number().int().min(1).max(5),
  comment: z.string().max(1000).optional(),
});

// 在路由中使用
app.post('/api/reviews', async (req, res) => {
  try {
    const data = reviewSchema.parse(req.body);
    // 处理请求...
  } catch (error) {
    res.status(400).json({
      success: false,
      error: { message: '参数验证失败' }
    });
  }
});
```

### 7.3 SQL注入防护

```typescript
// 使用Drizzle ORM（参数化查询）
const results = await db
  .select()
  .from(marathons)
  .where(eq(marathons.city, userInput)); // 自动转义

// 避免原始SQL（除非必要）
```

### 7.4 XSS防护

```typescript
// 1. 前端使用React（自动转义）
<div>{userComment}</div> // 安全

// 2. 后端存储前清理
import DOMPurify from 'isomorphic-dompurify';

const cleanComment = DOMPurify.sanitize(userComment);
```

### 7.5 速率限制

```typescript
import rateLimit from 'express-rate-limit';

// API速率限制
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 最多100次请求
  message: '请求过于频繁，请稍后再试',
});

app.use('/api/', apiLimiter);

// 登录速率限制
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 最多5次登录尝试
  message: '登录尝试次数过多，请15分钟后再试',
});

app.use('/api/auth/login', loginLimiter);
```

---

## 8. 监控与日志

### 8.1 日志系统

```typescript
// server/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error' 
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log' 
    }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}
```

### 8.2 性能监控

```typescript
// 请求耗时统计
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info('Request', {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration,
    });
    
    // 记录慢请求
    if (duration > 1000) {
      logger.warn('Slow request detected', {
        method: req.method,
        url: req.url,
        duration,
      });
    }
  });
  
  next();
});
```

### 8.3 错误追踪

```typescript
// 使用Sentry
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
});

// 错误处理中间件
app.use((err, req, res, next) => {
  Sentry.captureException(err);
  logger.error('Unhandled error', err);
  
  res.status(500).json({
    success: false,
    error: { message: '服务器内部错误' }
  });
});
```

---

## 9. 部署架构

### 9.1 生产环境架构

```
用户
  ↓
腾讯云CDN
  ↓
负载均衡（可选）
  ↓
┌───────────────────┐
│  Web服务器 x2     │
│  (PM2集群模式)    │
└───────┬───────────┘
        │
  ┌─────┴─────┐
  │           │
PostgreSQL  Redis
(云数据库)  (云缓存)
```

### 9.2 Docker部署

```dockerfile
# Dockerfile
FROM node:20-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://...
      - REDIS_URL=redis://...
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:14-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=marathon_calendar
      - POSTGRES_PASSWORD=...

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 9.3 PM2进程管理

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'marathon-api',
    script: 'dist/index.cjs',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
    },
    error_file: 'logs/err.log',
    out_file: 'logs/out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss',
  }],
};
```

---

## 10. 备份与灾备

### 10.1 数据备份策略

```bash
# 每日自动备份数据库
0 3 * * * /usr/bin/pg_dump marathon_calendar | gzip > /backups/db_$(date +\%Y\%m\%d).sql.gz

# 保留最近30天的备份
0 4 * * * find /backups -name "db_*.sql.gz" -mtime +30 -delete
```

### 10.2 灾难恢复计划

```
RTO (Recovery Time Objective): 1小时
RPO (Recovery Point Objective): 24小时

恢复步骤：
1. 启动新的云服务器实例
2. 恢复最近的数据库备份
3. 部署最新代码
4. 更新DNS解析
5. 验证系统功能
```

---

## 总结

本技术架构文档涵盖了马拉松日历应用的核心技术设计，包括：

1. **系统架构**：分层设计，职责清晰
2. **数据库设计**：合理的表结构和索引
3. **API设计**：RESTful规范，统一响应格式
4. **爬虫系统**：可扩展的数据采集架构
5. **缓存策略**：多级缓存提升性能
6. **安全措施**：全方位的安全防护
7. **监控日志**：及时发现和解决问题
8. **部署方案**：容器化部署，易于扩展

基于此架构，团队可以快速开发出稳定、高效、安全的马拉松日历应用。
